Templates in C++:

Q) Why use Templates ?
Ans:
   a) Follow DRY (don't repeat yourself (code)).
   b) A function template is used to perform the same function on multiple data types. 
   c) An alternative approach to this is using function overloading.

Templates are powerful features of C++ that allows us to write generic programs. There are two ways we can implement templates:

        1) Function Templates
        2) Class Templates

 *** Similar to function templates, we can use class templates to create a single class to work with different data types(int, float,char etc).

1) Class Template Declaration:
                               A class template starts with the keyword template followed by template parameter(s) inside <> which is followed by the class
                               declaration.
 Syntax:
         template <class T>
         class className {
         private:
                    T var;
                    ... .. ...
         public:
                T functionName(T arg);
                ... .. ...
};              
 --> In the above declaration, T is the template argument which is a placeholder for the data type used, and class is a keyword.

 --> Inside the class body, a member variable var and a member function functionName() are both of type T.   

 *** Creating a Class Template Object ***
  Once we've declared and defined a class template, we can create its objects in other classes or functions (such as the main() function) with the following
 
--> Syntax:      className<dataType> classObject;

Example:
        className<int> classObject;
        className<float> classObject;
        className<string> classObject;


Example:
       
// C++ program to demonstrate the use of class templates

#include <iostream>
using namespace std;

// Class template
template <class T>
class Number {
   private:
    // Variable of type T
    T num;

   public:
    Number(T n) : num(n) {}   // constructor

    T getNum() {
        return num;
    }
};

int main() {

    // create object with int type
    Number<int> numberInt(7);

    // create object with double type
    Number<double> numberDouble(7.7);

    cout << "int Number = " << numberInt.getNum() << endl;
    cout << "double Number = " << numberDouble.getNum() << endl;

    return 0;
}

Defining a Class Member Outside the Class Template:
                                                   Suppose we need to define a function outside of the class template. We can do this with the following 

Syntax:
       template <class T>
       class ClassName {
              ... .. ...
      // Function prototype
        returnType functionName(); 
       };

      // Function definition
         template <class T>
         returnType ClassName<T>::functionName() {
         // code
       }

 *** Notice that the code template <class T> is repeated while defining the function outside of the class. This is necessary and is part of the syntax.

 Example 2:

#include <iostream>
using namespace std;

template <class T>
class Calculator {
   private:
    T num1, num2;
   public:
    Calculator(T n1, T n2) {
        num1 = n1;
        num2 = n2;
    }
    void displayResult() {
        cout << "Numbers: " << num1 << " and " << num2 << "." << endl;
        cout << num1 << " + " << num2 << " = " << add() << endl;
        cout << num1 << " - " << num2 << " = " << subtract() << endl;
        cout << num1 << " * " << num2 << " = " << multiply() << endl;
        cout << num1 << " / " << num2 << " = " << divide() << endl;
    }
    T add() { return num1 + num2; }
    T subtract() { return num1 - num2; }
    T multiply() { return num1 * num2; }
    T divide() { return num1 / num2; }
};

int main() {
    Calculator<int> intCalc(2, 1);
    Calculator<float> floatCalc(2.4, 1.2);

    cout << "Int results:" << endl;
    intCalc.displayResult();

    cout << endl
         << "Float results:" << endl;
    floatCalc.displayResult();

    return 0;
}

Output:
Int results:
Numbers: 2 and 1.
2 + 1 = 3
2 - 1 = 1
2 * 1 = 2
2 / 1 = 2

Float results:
Numbers: 2.4 and 1.2.
2.4 + 1.2 = 3.6
2.4 - 1.2 = 1.2
2.4 * 1.2 = 2.88
2.4 / 1.2 = 2



*** Class Templates With Multiple Parameters :
                                              we can use multiple template parameters and even use default arguments for those parameters.

 Example:

template <class T, class U, class V = int>
class ClassName {
  private:
    T member1;
    U member2;
    V member3;
    ... .. ...
  public:
    ... .. ...
};

Example 3: C++ Templates With Multiple Parameters

#include <iostream>
using namespace std;

// Class template with multiple and default parameters
template <class T, class U, class V = char>
class ClassTemplate {
   private:
    T var1;
    U var2;
    V var3;

   public:
    ClassTemplate(T v1, U v2, V v3) : var1(v1), var2(v2), var3(v3) {}  // constructor

    void printVar() {
        cout << "var1 = " << var1 << endl;
        cout << "var2 = " << var2 << endl;
        cout << "var3 = " << var3 << endl;
    }
};

int main() {
    // create object with int, double and char types
    ClassTemplate<int, double> obj1(7, 7.7, 'c');
    cout << "obj1 values: " << endl;
    obj1.printVar();

    // create object with int, double and bool types
    ClassTemplate<double, char, bool> obj2(8.8, 'a', false);
    cout << "\nobj2 values: " << endl;
    obj2.printVar();

    return 0;
}

Output:
obj1 values: 
var1 = 7
var2 = 7.7
var3 = c

obj2 values: 
var1 = 8.8
var2 = a
var3 = 0


2) Function Template:
                     A function template starts with the keyword template followed by template parameter(s) inside <> which is followed by the function 
                     definition.

  Syntax:
         template <typename T>
         T functionName(T parameter1, T parameter2, ...) {
         // code
         }

--> In the above code, T is a template argument that accepts different data types (int, float, etc.), and typename is a keyword.

--> When an argument of a data type is passed to functionName(), the compiler generates a new version of functionName() for the given data type.

  Calling a Function Template:  functionName<dataType>(parameter1, parameter2,...);

  Example:
          
template <typename T>
T add(T num1, T num2) {
   return (num1 + num2);
}
int main() {

    int result1;
    double result2;
    // calling with int parameters
    result1 = add<int>(2, 3);
    cout << result1 << endl;

    // calling with double parameters
    result2 = add<double>(2.2, 3.3);
    cout << result2 << endl;

    return 0;
}    
Output:
        2 + 3 = 5
        2.2 + 3.3 = 5.5


               