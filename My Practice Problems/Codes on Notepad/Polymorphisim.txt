Polymorphisim:
              The word “polymorphism” means having many forms. In simple words, we can define polymorphism as the ability of a message 
              to be displayed in more than one form. A real-life example of polymorphism is a person who at the same time can have 
              different characteristics. A man at the same time is a father, a husband, and an employee. So the same person exhibits 
              different behavior in different situations. This is called polymorphism. Polymorphism is considered one of the important 
              features of Object-Oriented Programming.

Types of Polymorphism:
                      * Compile-time Polymorphism
                      * Runtime Polymorphism


1) Compile-time Polymorphism :
                              ** Compile-time Binding (Static Binding) **
                              
                               This type of polymorphism is achieved by function overloading or operator overloading.

  A) Function Overloading:

                        " When there are multiple functions with the same name but different parameters, then the functions are 
                          said to be overloaded, hence this is known as Function Overloading. Functions can be overloaded by 
                          changing the number of arguments or/and changing the type of arguments."

   Example:
          


  B) Operator Overloading:

                        " The ability to provide the operators with a special meaning for a data type, this ability is known as 
                          operator overloading. For example, we can make use of the addition operator (+) for string class to 
                          concatenate two strings. We know that the task of this operator is to add two operands. So a single 
                          operator ‘+’, when placed between integer operands, adds them and when placed between string operands,
                          concatenates them."


   Example:

#include <iostream>
using namespace std;

class Complex {
private:
	int real, imag;

public:
	Complex(int r = 0, int i = 0)
	{
		real = r;
		imag = i;
	}

	// This is automatically called
	// when '+' is used with between
	// two Complex objects
	Complex operator+(Complex const& obj)
	{
		Complex res;
		res.real = real + obj.real;
		res.imag = imag + obj.imag;
		return res;
	}
	void print() { cout << real << " + i" << imag << endl; }
};

// Driver code
int main()
{
	Complex c1(10, 5), c2(2, 4);

	// An example call to "operator+"
	Complex c3 = c1 + c2;
	c3.print();
}


 2) Runtime Polymorphism:
                         
                       " This type of polymorphism is achieved by Function Overriding. Late binding and dynamic polymorphism 
                         are other names for runtime polymorphism. The function call is resolved at runtime in runtime polymorphism.
                         In contrast, with compile time polymorphism, the compiler determines which function call to bind to the object
                         after deducing it at runtime."

  A) Function Overriding:

                        Function Overriding occurs when a derived class has a definition for one of the member functions of the base class.
                        That base  function is said to be overridden.

*** Runtime Polymorphism with Data Members:
                                            Runtime Polymorphism cannot be achieved by data members in C++. Let’s see an example where we
                                            are accessing the field by reference variable of parent class which refers to the instance of
                                            the derived class.
  Example:

// C++ program for function overriding with data members
#include <bits/stdc++.h>
using namespace std;

// base class declaration.
class Animal {
public:
	string color = "Black";
};

// inheriting Animal class.
class Dog : public Animal {
public:
	string color = "Grey";
};

// Driver code
int main(void)
{
	Animal d = Dog(); // accessing the field by reference
					// variable which refers to derived
	cout << d.color;
}

 Output:
        Black

 $ We can see that the parent class reference will always refer to the data member of the parent class. $

 B) Virtual Function:

                   " A virtual function is a member function that is declared in the base class using the keyword virtual and
                     is re-defined (Overridden) in the derived class."

*** Some Key Points About Virtual Functions:
                                            1) Virtual functions are Dynamic in nature. 
                                            2) They are defined by inserting the keyword “virtual” inside a base class and are always declared
                                               with a base class and overridden in a child class.
                                            3) A virtual function is called during Runtime


  Example: 1
 
// C++ Program to demonstrate
// the Virtual Function
#include <iostream>
using namespace std;

// Declaring a Base class
class GFG_Base {

public:
	// virtual function
	virtual void display()
	{
		cout << "Called virtual Base Class function"
			<< "\n\n";
	}

	void print()
	{
		cout << "Called GFG_Base print function"
			<< "\n\n";
	}
};

// Declaring a Child Class
class GFG_Child : public GFG_Base {

public:
	void display()
	{
		cout << "Called GFG_Child Display Function"
			<< "\n\n";
	}

	void print()
	{
		cout << "Called GFG_Child print Function"
			<< "\n\n";
	}
};

// Driver code
int main()
{
	// Create a reference of class GFG_Base
	GFG_Base* base;

	GFG_Child child;

	base = &child;

	// This will call the virtual function
	base->GFG_Base::display();

	// this will call the non-virtual function
	base->print();
}

 Output:
        Called virtual Base Class function

        Called GFG_Base print function


 Example 2:

// C++ program for virtual function overriding
#include <bits/stdc++.h>
using namespace std;

class base {
public:
	virtual void print()
	{
		cout << "print base class" << endl;
	}

	void show() { cout << "show base class" << endl; }
};

class derived : public base {
public:
	// print () is already virtual function in
	// derived class, we could also declared as
	// virtual void print () explicitly
	void print() { cout << "print derived class" << endl; }

	void show() { cout << "show derived class" << endl; }
};

// Driver code
int main()
{
	base* bptr;
	derived d;
	bptr = &d;

	// Virtual function, binded at
	// runtime (Runtime polymorphism)
	bptr->print();

	// Non-virtual function, binded
	// at compile time
	bptr->show();

	return 0;
}

 Output:
        print derived class
           show base class



               
    
